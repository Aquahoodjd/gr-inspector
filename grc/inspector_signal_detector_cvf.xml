<block>
  <name>Signal Detector</name>
  <key>inspector_signal_detector_cvf</key>
  <category>[Inspector]/Conditioning</category>
  <import>import inspector</import>
  <make>inspector.signal_detector_cvf($samp_rate, $fft_len, $window,
    $threshold, $sensitivity, $auto, $avg, $quant, $min_bw)</make>
  <callback>set_fft_len($fft_len)</callback>
  <callback>set_window_type($window)</callback>
  <callback>set_samp_rate($samp_rate)</callback>
  <callback>set_threshold($threshold)</callback>
  <callback>set_sensitivity($sensitivity)</callback>
  <callback>set_auto_threshold($auto)</callback>
  <callback>set_average($avg)</callback>
  <callback>set_quantization($quant)</callback>
  <param>
    <name>Samp rate</name>
    <key>samp_rate</key>
    <type>real</type>
  </param>
  <param>
    <name>FFT length</name>
    <key>fft_len</key>
    <value> 1024</value>
    <type>int</type>
  </param>
  <param>
    <name>Window</name>
    <key>window</key>
    <value>firdes.WIN_BLACKMAN_hARRIS</value>
    <type>enum</type>
    <option>
      <name>Blackman-harris</name>
      <key>firdes.WIN_BLACKMAN_hARRIS</key>
    </option>
    <option>
      <name>Hamming</name>
      <key>firdes.WIN_HAMMING</key>
    </option>
    <option>
      <name>Hann</name>
      <key>firdes.WIN_HANN</key>
    </option>
    <option>
      <name>Blackman</name>
      <key>firdes.WIN_BLACKMAN</key>
    </option>
    <option>
      <name>Rectangular</name>
      <key>firdes.WIN_RECTANGULAR</key>
    </option>
    <option>
      <name>Kaiser</name>
      <key>firdes.WIN_KAISER</key>
    </option>
    <option>
      <name>Flat-top</name>
      <key>firdes.WIN_FLATTOP</key>
    </option>
  </param>
  <param>
    <name>Auto threshold</name>
    <key>auto</key>
    <value>True</value>
    <type>bool</type>
    <option>
      <name>On</name>
      <key>True</key>
    </option>
    <option>
      <name>Off</name>
      <key>False</key>
    </option>
  </param>
  <param>
    <name>Threshold (dB)</name>
    <key>threshold</key>
    <value> 0.7</value>
    <type>float</type>
    <hide>#if str($auto) == 'True' then 'all' else 'none'#</hide>
  </param>
  <param>
    <name>Sensitivity (0-1)</name>
    <key>sensitivity</key>
    <value> 0.2</value>
    <type>float</type>
    <hide>#if str($auto) == 'True' then 'none' else 'all'#</hide>
  </param>
  <param>
    <name>Average IIR alpha</name>
    <key>avg</key>
    <value>0.8</value>
    <type>real</type>
  </param>
  <param>
    <name>Rel. quantization</name>
    <key>quant</key>
    <value>0.0001</value>
    <type>real</type>
    <hide>part</hide>
  </param>
  <param>
    <name>Min Sig BW</name>
    <key>min_bw</key>
    <value>0</value>
    <type>real</type>
    <hide>part</hide>
  </param>
  <sink>
    <name>in</name>
    <type>complex</type>
  </sink>
  <source>
    <name>out</name>
    <type>float</type>
    <vlen>$fft_len</vlen>
    <optional>1</optional>
  </source>
  <source>
    <name>map_out</name>
    <type>message</type>
    <optional>1</optional> 
 </source>
  <doc>
Takes input spectrum as complex float and performs an energy detection to find potential signals and build a RF map. The RF map gets passed as a message with center frequency and bandwidth information for each detected signal.

Threshold for energy detection can either be set in dB or an automatic threshold calculation can be performed by setting a sensitivity between 0 and 1. The PSD is then sorted and searched for relative power jumps with height (1-sensitivity) and the threshold is set to the sample before that jump (which should be the strongest noise sample).

To surpress false detection in noisy scenarios, the minimum signal bandwidth can be set. All detected signals smaller than this value will not be written in the RF map.

To average the PSD (and provide a better detection) an single pole IIR filter is implemented in this block. The parameter alpha can be set as block parameter. The IIR equation yields y[n] = alpha*x[n]+(1-alpha)*y[n-1].

The bandwidth of the detected signals can be quantized relative to the sampling rate. This leads to less recalculations in the Signal Separator block. There, a filter must be recalculated, when the bandwidth of a signal changed.
  </doc>
</block>
